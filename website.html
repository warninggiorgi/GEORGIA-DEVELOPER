<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Secure Messenger — P2P encrypted rooms (password)</title>
<style>
  :root{
    --bg:#0f1115; --panel:#0e1013; --card:#111317; --muted:#9fb0d3; --accent:#1f6feb; --bubble-me:#163a59; --bubble-peer:#2a2a2a; --text:#e6eef6;
  }
  body{margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,Helvetica,sans-serif}
  .app{display:flex;height:100vh}
  .sidebar{width:320px;background:var(--panel);border-right:1px solid #0b0c0d;padding:18px;box-sizing:border-box;overflow:auto}
  .main{flex:1;display:flex;flex-direction:column}
  h1{font-size:18px;margin:0 0 8px 0}
  .card{background:var(--card);border-radius:10px;padding:12px;margin-bottom:12px}
  label{display:block;color:var(--muted);font-size:12px;margin-top:8px}
  input[type=text], input[type=password], textarea, select{
    width:100%;padding:8px;border-radius:8px;border:1px solid #222;background:#0c0d0f;color:var(--text);box-sizing:border-box;margin-top:6px;font-family:monospace
  }
  button{background:var(--accent);color:white;border:0;padding:8px 10px;border-radius:8px;cursor:pointer}
  .rooms{margin-top:12px}
  .room-item{padding:8px;border-radius:8px;margin-bottom:8px;background:#0b0c0e;display:flex;justify-content:space-between;align-items:center}
  .room-item .name{font-weight:600}
  .room-item .small{font-size:12px;color:var(--muted)}
  .chat-header{padding:12px;border-bottom:1px solid #0b0c0d;background:linear-gradient(0deg,rgba(255,255,255,0.01),transparent)}
  .chat-area{flex:1;padding:12px;display:flex;flex-direction:column;gap:12px;overflow:auto;background:linear-gradient(180deg, rgba(255,255,255,0.01), transparent)}
  .bubbles{display:flex;flex-direction:column;gap:8px;max-width:100%}
  .bubble{max-width:70%;padding:10px 12px;border-radius:12px;word-break:break-word}
  .bubble.me{align-self:flex-end;background:linear-gradient(180deg,var(--bubble-me),#164b6a);color:white;border-bottom-right-radius:4px}
  .bubble.peer{align-self:flex-start;background:var(--bubble-peer);color:#f8f1e6;border-bottom-left-radius:4px}
  .msg-meta{font-size:11px;color:var(--muted);margin-top:6px}
  .chat-controls{display:flex;gap:8px;padding:12px;border-top:1px solid #0b0c0d;background:var(--card)}
  .chat-controls input{flex:1}
  .note{font-size:12px;color:var(--muted);margin-top:8px}
  .small{font-size:12px;color:var(--muted)}
  .danger{background:#3a1a1a;color:#ffcccc;padding:8px;border-radius:8px}
  @media(max-width:900px){ .sidebar{width:100%;height:auto} .app{flex-direction:column} .main{height:calc(100vh - 300px)} }
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <h1>Secure Messenger</h1>
    <div class="card">
      <div class="small">Create or join a room. Each room is protected by a password. Password automatically derives the encryption key — no extra steps.</div>

      <label>Room name</label>
      <input id="roomName" type="text" placeholder="my-room" value="room-1" />

      <label>Password</label>
      <input id="roomPass" type="password" placeholder="choose a secret" />

      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="createBtn">Create Room</button>
        <button id="joinBtn">Join Room</button>
      </div>

      <div class="note">After Create: a Local SDP appears. Copy it and send to remote user (via any channel). Remote user pastes it in 'Remote SDP' and clicks 'Apply'. Remote will produce their SDP to send back. Paste that into 'Remote SDP' on the creator side and click Apply. That's the manual signaling — no servers used.</div>
    </div>

    <div class="card">
      <label>Local SDP (share this with peer)</label>
      <textarea id="localSDP" placeholder="local SDP will appear here"></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="copyLocal">Copy</button>
        <button id="clearLocal">Clear</button>
      </div>

      <label style="margin-top:10px">Remote SDP (paste peer SDP & Apply)</label>
      <textarea id="remoteSDP" placeholder="paste remote SDP here"></textarea>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="applyRemote">Apply Remote SDP</button>
      </div>
    </div>

    <div class="card">
      <div class="small">Active rooms (local only)</div>
      <div id="roomsList" class="rooms"></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="leaveBtn">Leave Room</button>
        <button id="clearBtn">Clear All</button>
      </div>
      <div class="note">Rooms are ephemeral — stored only in this tab. For persistent rooms you need a server for discovery/signaling.</div>
    </div>

    <div class="card small">
      <div><strong>Notes</strong></div>
      <ul>
        <li>Manual signaling is required (copy/paste). This prevents any remote server involvement.</li>
        <li>Use a strong password and share it out-of-band (via call or other secure channel).</li>
        <li>Works best via HTTPS or localhost.</li>
      </ul>
    </div>
  </aside>

  <main class="main">
    <div class="chat-header card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <div id="activeRoomName" style="font-weight:700">No room</div>
          <div id="activeRoomState" class="small">Not connected</div>
        </div>
        <div>
          <button id="downloadChat">Download Chat</button>
          <button id="copyChat">Copy Chat</button>
        </div>
      </div>
    </div>

    <div id="chatArea" class="chat-area">
      <div id="bubbles" class="bubbles"></div>
    </div>

    <div class="chat-controls card">
      <input id="msgInput" type="text" placeholder="Type a message..." />
      <button id="sendBtn">Send</button>
    </div>
  </main>
</div>

<script>
/*
  Secure Messenger — single-file
  - Room = roomName + password
  - Key derived automatically from password + roomName (PBKDF2)
  - WebRTC DataChannel for messages
  - Manual signaling: copy/paste SDP
  - Messages encrypted with AES-GCM and send as base64
  - No external servers
*/

// Helpers
const $ = id => document.getElementById(id);
const log = (t, cls='') => {
  const el = document.createElement('div');
  el.textContent = t;
  if(cls) el.className = cls;
  $('bubbles').appendChild(el);
  $('chatArea').scrollTop = $('chatArea').scrollHeight;
};
function now(){ return new Date().toLocaleString(); }
function t2b(t){ return new TextEncoder().encode(t); }
function b2t(b){ return new TextDecoder().decode(b); }
function concat(a,b){ const r=new Uint8Array(a.length+b.length); r.set(a,0); r.set(b,a.length); return r; }
function abToB64(buf){ let bin=''; const arr=new Uint8Array(buf); for(let i=0;i<arr.length;i++) bin += String.fromCharCode(arr[i]); return btoa(bin); }
function b64ToAb(b64){ const bin=atob(b64); const len=bin.length; const arr=new Uint8Array(len); for(let i=0;i<len;i++) arr[i]=bin.charCodeAt(i); return arr.buffer; }

// Crypto
let ROOM_KEY = null; // CryptoKey AES-GCM
async function deriveRoomKey(password, roomName){
  const salt = t2b('room-salt:' + roomName);
  const pw = await crypto.subtle.importKey('raw', t2b(password), 'PBKDF2', false, ['deriveKey']);
  const key = await crypto.subtle.deriveKey({
    name: 'PBKDF2',
    salt,
    iterations: 200000,
    hash: 'SHA-256'
  }, pw, { name: 'AES-GCM', length: 256 }, false, ['encrypt','decrypt']);
  ROOM_KEY = key;
  return key;
}

async function encryptText(plain){
  if(!ROOM_KEY) throw new Error('No key derived');
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, ROOM_KEY, t2b(plain));
  const combined = concat(iv, new Uint8Array(ct));
  return abToB64(combined.buffer);
}

async function decryptText(b64){
  if(!ROOM_KEY) throw new Error('No key derived');
  const buf = b64ToAb(b64);
  const arr = new Uint8Array(buf);
  const iv = arr.slice(0,12);
  const ct = arr.slice(12);
  const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, ROOM_KEY, ct);
  return b2t(pt);
}

// UI elements
const roomNameIn = $('roomName'), roomPassIn = $('roomPass'), createBtn = $('createBtn'), joinBtn = $('joinBtn');
const localSDP = $('localSDP'), remoteSDP = $('remoteSDP'), copyLocal = $('copyLocal'), applyRemote = $('applyRemote'), clearLocal = $('clearLocal');
const roomsList = $('roomsList'), leaveBtn = $('leaveBtn'), clearBtn = $('clearBtn');
const activeRoomName = $('activeRoomName'), activeRoomState = $('activeRoomState');
const msgInput = $('msgInput'), sendBtn = $('sendBtn'), bubbles = $('bubbles');
const downloadChat = $('downloadChat'), copyChat = $('copyChat');

// Peer connection
let pc = null;
let dc = null;
let currentRoom = null; // {name, createdByMe:bool}
let localSDPText = '';

// Utility: add message bubble
function addBubble(text, who='me'){
  const div = document.createElement('div');
  div.className = 'bubble ' + (who==='me' ? 'me' : 'peer');
  div.innerHTML = `<div>${escapeHtml(text)}</div><div class="msg-meta">${now()}</div>`;
  bubbles.appendChild(div);
  $('chatArea').scrollTop = $('chatArea').scrollHeight;
}
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

// Create/Join flows
createBtn.onclick = async () => {
  const room = roomNameIn.value.trim();
  const pass = roomPassIn.value;
  if(!room || !pass){ alert('Enter room name and password'); return; }
  try{
    await deriveRoomKey(pass, room);
  }catch(e){ alert('Derive key failed: '+e.message); return; }

  // set UI
  currentRoom = { name: room, createdByMe: true };
  activeRoomName.textContent = room + ' (creator)';
  activeRoomState.textContent = 'Creating peer connection...';
  addRoomLocal(room);

  // create pc + datachannel
  if(pc){ pc.close(); pc=null; dc=null; }
  pc = new RTCPeerConnection();
  dc = pc.createDataChannel('messenger', { ordered:true });
  setupDataChannel(dc);
  pc.onicecandidate = e => {
    if(e.candidate === null){
      // ICE finished
      localSDP.value = pc.localDescription ? pc.localDescription.sdp : '';
      activeRoomState.textContent = 'Local SDP ready — share to peer';
    }
  };
  pc.onconnectionstatechange = () => activeRoomState.textContent = 'Connection: ' + pc.connectionState;
  pc.oniceconnectionstatechange = () => console.log('ICE:', pc.iceConnectionState);

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // waiting for ICE to finish — localSDP will be set on onicecandidate null
};

joinBtn.onclick = async () => {
  const room = roomNameIn.value.trim();
  const pass = roomPassIn.value;
  if(!room || !pass){ alert('Enter room name and password'); return; }
  try{
    await deriveRoomKey(pass, room);
  }catch(e){ alert('Derive key failed: '+e.message); return; }

  currentRoom = { name: room, createdByMe: false };
  activeRoomName.textContent = room + ' (joiner)';
  activeRoomState.textContent = 'Waiting for remote offer; paste it below and click Apply';

  addRoomLocal(room);
  if(pc){ pc.close(); pc=null; dc=null; }
  pc = new RTCPeerConnection();
  pc.ondatachannel = ev => {
    dc = ev.channel;
    setupDataChannel(dc);
  };
  pc.onicecandidate = e => {
    if(e.candidate === null){
      localSDP.value = pc.localDescription ? pc.localDescription.sdp : '';
      activeRoomState.textContent = 'Local SDP ready — send to creator';
    }
  };
  pc.onconnectionstatechange = () => activeRoomState.textContent = 'Connection: ' + pc.connectionState;
};

// Apply remote (both sides)
applyRemote.onclick = async () => {
  if(!pc){ alert('Start create or join first'); return; }
  const sdp = remoteSDP.value.trim();
  if(!sdp){ alert('Paste remote SDP'); return; }
  try{
    const isCreator = currentRoom && currentRoom.createdByMe;
    const remoteType = isCreator ? 'answer' : 'offer';
    await pc.setRemoteDescription({ type: remoteType, sdp });
    activeRoomState.textContent = 'Remote description applied';
    if(!isCreator){
      // we are joiner: create answer
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      activeRoomState.textContent = 'Answer created; share it with creator';
    } else {
      // creator applied remote answer; connection flow continues
      activeRoomState.textContent = 'Answer applied; connecting...';
    }
  }catch(e){
    alert('Apply remote error: ' + e.message);
  }
};

// DataChannel setup
function setupDataChannel(channel){
  channel.onopen = () => {
    activeRoomState.textContent = 'Connected';
    addSystem('DataChannel open');
  };
  channel.onclose = () => {
    activeRoomState.textContent = 'Closed';
    addSystem('DataChannel closed');
  };
  channel.onmessage = async e => {
    try{
      const payload = JSON.parse(e.data);
      if(payload.type === 'msg'){
        const text = await decryptText(payload.data);
        addBubble(text, 'peer');
      } else {
        addSystem('Unknown payload');
      }
    }catch(err){
      addSystem('Decrypt error: ' + err.message);
    }
  };
}
function addSystem(txt){ const div=document.createElement('div'); div.className='small'; div.style.color='#9fb0d3'; div.textContent = txt; bubbles.appendChild(div); }

// Send message (encrypt before sending)
sendBtn.onclick = async () => {
  const text = msgInput.value.trim();
  if(!text) return;
  if(!dc || dc.readyState !== 'open'){ addSystem('Not connected'); return; }
  try{
    const enc = await encryptText(text);
    const payload = JSON.stringify({ type:'msg', data: enc });
    dc.send(payload);
    addBubble(text, 'me');
    msgInput.value = '';
  }catch(e){
    addSystem('Send error: ' + e.message);
  }
};

// Copy local SDP
copyLocal.onclick = async () => {
  const txt = localSDP.value;
  if(!txt) { alert('Local SDP empty'); return; }
  try{ await navigator.clipboard.writeText(txt); addSystem('Local SDP copied to clipboard'); } catch(e){ addSystem('Copy failed'); }
};
clearLocal.onclick = () => { localSDP.value=''; remoteSDP.value=''; };

// Room list local
function addRoomLocal(name){
  // avoid duplicates
  if(Array.from(roomsList.children).some(c=>c.dataset.name===name)) return;
  const div = document.createElement('div');
  div.className='room-item';
  div.dataset.name = name;
  div.innerHTML = `<div><div class="name">${escapeHtml(name)}</div><div class="small">local</div></div><div><button class="enter">Enter</button></div>`;
  roomsList.appendChild(div);
  div.querySelector('.enter').onclick = () => {
    roomNameIn.value = name;
    addSystem('Selected room: '+name);
  };
}
leaveBtn.onclick = () => {
  if(pc){ pc.close(); pc=null; dc=null; }
  currentRoom = null;
  activeRoomName.textContent = 'No room';
  activeRoomState.textContent = 'Not connected';
  addSystem('Left room');
};
clearBtn.onclick = () => { roomsList.innerHTML=''; addSystem('Cleared rooms list'); };

// Chat export
downloadChat.onclick = () => {
  const text = Array.from(bubbles.children).map(n=>n.innerText).join('\n');
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='chat.txt'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
  addSystem('Chat downloaded');
};
copyChat.onclick = async () => {
  try{ await navigator.clipboard.writeText(Array.from(bubbles.children).map(n=>n.innerText).join('\n')); addSystem('Chat copied to clipboard'); } catch(e){ addSystem('Copy failed'); }
};

// simple escape
function escapeHtml(s){ return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

// quick instruction hint
addSystem('UI ready. Create a room, share the Local SDP with the other user, they paste it and Apply, then share their SDP back. Messages are encrypted with the room password.');
</script>
</body>
</html>
